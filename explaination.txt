1. checking django version -> python -m django --version
2. creating a django project -> django-admin startproject mysite,
where 'mysite' is the name of the project. The 

/*
mysite/
    manage.py
    mysite/
        __init__.py
        settings.py
        urls.py
        asgi.py
        wsgi.py
*/
mysite -> container of the project 
manage.py -> this is the command utility thats helps in interacting with the django project. It is used in place of django-admin
__init__.py -> tells python that this directory should be considered as a python package
mysite -> this is a actual project ( name of the app -> mysite ), the inner mysite 
settings.py -> the settings/configuration of the app ( not the project ) like installed apps, middlewares, static files, wsgi, templates, databases
auth password validators.
urls.py -> This file maps all the urls of the project. This is the place where the urls are defined.
asgi.py -> entry point for asgi web servers 
wsgi.py -> entry point for wsgi web servers

3. running the project -> python manage.py runserver
Default port -> 8000 on the localhost
can also change the port -> python manage.py runserver 0.0.0.0:8001

4. A view is a “type” of web page in your Django application that generally serves a specific function and has a specific template.
    In Django, web pages and other content are delivered by views. Each view is represented by a Python function (or method, in the case of class-based views). 
    Django will choose a view by examining the URL that’s requested (to be precise, the part of the URL after the domain name).

    Each view is responsible for doing one of two things: returning an HttpResponse object containing the content for the requested page, or raising an exception such as Http404. The rest is up to you.

    Your view can read records from a database, or not. It can use a template system such as Django’s – or a third-party Python template system – or not. It can generate a PDF file, output XML, create a ZIP file on the fly, anything you want, using whatever Python libraries you want.

    All Django wants is that HttpResponse. Or an exception.



5. default configurations of django uses SQLite as the database. If you want to use any other database like -> postgresql, oracle, mysql then
    you can edit the settings.py file and change the ENGINE and the NAME and install the appropriate database binding

6. INSTALLED_APPS -> By default 
    1. admin -> The admin site
    2. auth -> the authentication system
    3. contenttypes -> A framework for contenttypes
    4. sessions -> a session framework 
    5. messages -> a messsaging framework 
    6. statisfles -> The framework to manage static files

7. MIGRATE command -> migrate command looks at the installed_apps settings and creates an appropriate database table according to 
    the settings.py file and the database migrations are shifted to the app. This creates a db.sqlie3 file ( if using sqlite )

8. to use the django shell, run the python manage.py shell command

9. Django-admin : Generating admin sites for your staff or clients to add, change, and delete content is 
    tedious work that doesn’t require much creativity. For that reason, Django entirely automates creation of admin 
    interfaces for models.

9. Making the polls app modifiable in the admin : 
    we need to tell the admin that, there is a Question model, so that it can modify it 
    do it by adding admin.site.register(Question) in the polls/admin.py 



10. static files : 

For small projects, this isn’t a big deal, because you can keep the static files somewhere your web server can find it. However, in bigger projects – especially those comprised of multiple apps – dealing with the multiple sets of static files provided by each application starts to get tricky.

That’s what django.contrib.staticfiles is for: it collects static files from each of your applications (and any other places you specify) into a single location that can easily be served in production.

Just like templates, we might be able to get away with putting our static files directly in polls/static (rather than creating another polls subdirectory), but it would actually be a bad idea. Django will choose the first static file it finds whose name matches, and if you had a static file with the same name in a different application, Django would be unable to distinguish between them. We need to be able to point Django at the right one, and the best way to ensure this is by namespacing them. That is, by putting those static files inside another directory named for the application itself.

"""
WARNING : 
The {% static %} template tag is not available for use in static files which aren’t generated by Django, like your stylesheet. 
You should always use relative paths to link your static files between each other, because then you can change STATIC_URL (used by the static template tag to generate its URLs) without having to modify a bunch of paths in your static files as well.

"""